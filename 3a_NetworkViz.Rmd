---
title: "Network visualization"
author: "Pablo Gomez"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = F, message = F)
library(dplyr); library(ggplot2); library(ggpubr);library(Pabloverse)
```


In this lab we will start making our first network objects, obtain network statistics and some visualization of the data.  


# Network visualization

## Loading the data and visualizing the network

```{r message = F, warning = F}
# Libraries we will use:
library(dplyr) # for data manipulation
library(ggplot2) # For making figures
library(ggraph) # For ploting the networks
library(igraph) # for network analysis
library(tidygraph) # tidyverse friendly network analysis
# Loading the data from the STNet package
node <- STNet::SwinePrem %>% 
  mutate(id = as.character(id))

edge <- STNet::SwineMov %>% 
  mutate(id_orig = as.character(id_orig), id_dest = as.character(id_dest))
```


The data sets we will be using are:
  
  - `node` which includes the information of the farms 
  - `edge` which includes the information for the movements between the farms.  

We use the function `as_tbl_graph()` to create the network from a data.frame. This function takes as arguments:`x`  which requires the contacts data and assumes that contacts are directed. If we print the results, we will see a object from the class `tbl_graph`, which we will explain:

```{r create the network}
net <- as_tbl_graph(edge)

net
```

The results of printing the object will show us the number of nodes and edges, we can see that our network has 40 nodes and 1611 edges. Then we can also see the attributes for the nodes (which in this case there is only the name) and the edges (which for this example has from, to, date, pigs.moved, type_orig, and type_dest).  
  
We can treat this object like two data frames that are joined by an key or identification variable. Whenever we want to access one of the data frames to modify it, we can use either the function `activate()` or when using the pipes we can use `%N>%` to call the nodes or `%E>%` to call the edges. In the next example we will add the rest of the node information to our `tbl_graph`

```{r}
net <- net %N>% # <- Notice we are including 'N' inside our pipe to specify we want to access the nodes
  left_join(node, by = c('name' = 'id')) # Now we join to the node dataframe to include other variables
```


```{r eval = F}
# We can ask for the nodes data specifically to see the changes
net %N>% 
  data.frame() %>% 
  View()
```


To visualize the network we can use the function `plot()`.  

```{r}
#plot network#
#for help look look for: ?plot.igraph#
plot(net)
```

This figure looks a bit messy, to make it more informative we can visualize dome of the parameters. We use the arguments `edge.arrow.size` to adjust the size of the arrowhead, `vertex.size` to adjust the node size, and `vertex.label` to remove the names of the nodes.  

```{r}
#make it clearer: adjust size, remove labels#
plot(net, # Our network object
     edge.arrow.size=0.2, # define the arrow size
     vertex.size=4,  # the sie of the node
     vertex.label=NA) # We remove the name of the nodes
```

**Exercise:** Change the size of the nodes and the arrows to make a different graph.  

## Using ggraph

We can use base R to make our figures, but since we will be focusing on ggplot2, we will use the library ggraph which is based in ggplot2.  

### Changing the node color

We can get specific attributes from the `tbl_graph` inside the `aes()` argument, similar to what we would do for ggplot2. In the following plot, we will set the node color to the type of farm.  

```{r}
ggraph(graph = net) + # First we call the ggraph and specify our network
  geom_edge_link() + # Add the edges
  geom_node_point(aes(color = farm_type), size = 3) # add the nodes
```


## Layouts

We can change the position of the nodes using the argument `layout`. If we don't specify any layout, ggraph will automatically set the layout 'stress'. Force directed layouts place the nodes in fixed places based on various criteria. The layouts 'nicely' and 'kk' force the network in clear layouts, based on the position of the nodes in the network in terms of connectivity.  They also attempt to keep the distance between connected nodes fixed.

```{r}
# Plot with layout nicely
ggraph(net, layout = 'nicely') +
  geom_edge_link() + # Add the edges
  geom_node_point(aes(color = farm_type), size = 3) + # add the nodes
  labs(title = 'Layout nicely')

# Plot with layout kk
ggraph(net, layout = 'kk') +
  geom_edge_link() + # Add the edges
  geom_node_point(aes(color = farm_type), size = 3) +
  labs(title = 'Layout KK')
```

You can read more about the different layours available [HERE](https://ggraph.data-imaginist.com/articles/Layouts.html)

Now we will use different layouts to see how the network changes.  

**Excercise:** Try different layouts: 'fr', 'lgl', 'graphopt'.    


## Size of the edge

```{r}
ggraph(net, layout = 'kk') +
  geom_edge_link(aes(width = pigs.moved)) + # Add the edges
  geom_node_point(aes(color = farm_type), size = 3) +
  scale_edge_width(range = c(0.01, 0.9))
```
  
  
## Node size

We will use the indegree value to assign the node size. First we will calculate indegree using the function `centrality_degree()` with the argument `mode = "in"`, and we will also get rid of the loops with the argument `loops = F`.    

```{r}
net <- net %>% 
  mutate(indegree = centrality_degree(mode = 'in', loops = F))

ggraph(net, layout = 'kk') +
  geom_edge_link(aes(width = pigs.moved)) + # Add the edges
  geom_node_point(aes(color = farm_type, size = indegree)) +
  scale_edge_width(range = c(0.01, 0.9))
```

We can use other network centrality measures such as outdegree, closeness, betwenness, among others.

```{r}
net <- net %>% 
  mutate(outdegree  = centrality_degree(mode = 'out', loops = F),
         closeness = centrality_closeness(),
         betweenness = centrality_betweenness(),
         Nbs = neighborhood.size(graph = .)
         )

net
```


**Excercise:** explore plotting the network using the different centrality measures to change its color or size.  


# Using other packages to plot the network

## Interactive visualization using networkD3

The package `networkD3` offer some interesting visualization options. This package uses javascript to create interactive visualizations so we need to start our indexing at 0 and not at 1 for the edges. for this we will substract 1 to the edges indexing

```{r}
# Loading the library
library(networkD3)
# SUbstract 1 from the indexing of the nodes
edge_s <- edge %>%
  count(id_orig, id_dest) %>%
  mutate(id_orig = as.numeric(id_orig) - 1, id_dest = as.numeric(id_dest) - 1)

# Plot a simple network
simpleNetwork(edge_s)
```

We can also add more information to our network such as the name, type of node and size of the edges.  

```{r}
# Plot
forceNetwork(Links = edge_s, Nodes = node,
            Source = "id_orig", Target = "id_dest",
            Value = "n", NodeID = "name",
            Group = "farm_type", opacity = 0.8)
```

Another interesting visualization from this package are the Sankey Networks. THis type of visualizations can be very helpful to se the flow of the movements. The height of the rectangles will represent the indegree, and the shaded line between two nodes represent the number of movements between a pair of nodes

```{r}
# Plot
sankeyNetwork(Links = edge_s, Nodes = node, Source = "id_orig",
             Target = "id_dest", Value = "n", NodeID = "name",
             fontSize = 12, nodeWidth = 30)
```
  
  
# Calculating euclidean distance

We can also use the spatial location of the nodes to calculate the distance between a movement. To represent this distance we use euclidean distance, which is the distance using a straight line between two locations.  
We will use the package `raster` for this part, so make sure its installed.  

```{r warning=F, message=F}
library(raster)
# First we need to include the information of origins and destination
edge <- edge %>%
  left_join(node[c("id", "lat", "long")], by = c("id_orig" = "id")) %>%
  rename(O_Lat = lat, O_Long = long) %>%
  left_join(node[c("id", "lat", "long")], by = c("id_dest" = "id")) %>%
  rename(D_Lat = lat, D_Long = long)
# Now we calculate the distance
edge$dist <- pointDistance(p1 = edge[c("O_Long", "O_Lat")], # Origin coordinates
                           p2 = edge[c("D_Long", "D_Lat")], # Destination coordinates
                           lonlat = T)

# We convert from m to km
summary(edge$dist/1000)
# We can see the quantiles:
quantile(edge$dist/1000, c(0.05,0.95))
# Lets look the distribution of distances
hist(edge$dist/1000, 
     xlim=range(0,500),
     breaks=20,  
     main = "Distribution of euclidean distance (Km)", xlab="distance (km)")

boxplot(edge$dist/1000,
        ylim=c(0,500),
        main = "Boxlot of euclidean distance (Km)", ylab="distance (km)")
```



```{r}
node <- net %N>% 
  data.frame()
```

Now we will add the network statistics to the data.frame and export the objects so we can load it in another session.  

```{r eval = F}
# we can export the network as a RDS object using the package readr

readr::write_rds(net, "Data/Outputs/net.rds")
# We will also export the edges with the distance and coordinates
write.csv(edge, "Data/Outputs/edge.csv", row.names = F)
write.csv(node, "Data/Outputs/node.csv", row.names = F)
```


In this lab we will review concepts of community detection and how to represent our network in a map.  

First we will load the data and the libraries we will be using. Remember that on the previous lab we exported a data set at the end, we will continue using this objects.  

```{r}
# If you are starting a new session, load the files and libraries again 
# Load the data
net <- readRDS("Data/Outputs/net.rds") # Loading the network object
node <- read.csv("Data/Outputs/node.csv") # loading the nodes
edge <- read.csv("Data/Outputs/edge.csv") # Loading the edges

# libraries we will use.
library(dplyr) # Data manipulation
library(sf) # Spatial data manipulation
library(tidygraph) # Network manipulation and analysis
library(purrr) # for data manipulation
library(ggraph) # for network visualization
library(ggpubr) # for arranging plots
```


```{r}
Net <- edge %>% 
  select(type_orig, type_dest) %>% 
  as_tbl_graph() %N>% 
  mutate(Degree = centrality_degree()) %E>% 
  mutate(N = as.integer(1)) %>%  # create a variable for the number of movements (each row is 1 movement)
  convert(to_simple) %E>%  # now we will convert it to a simple network
  mutate(weight = map_int(.orig_data, ~.x %>% pull(N) %>% sum())) 

Net %>% 
  ggraph(layout = 'kk') + # call the ggraph function
  geom_edge_link(aes(width = weight), colour = 'grey20', 
                 arrow = arrow(angle = 35, length = unit(.4, 'cm'))) + # add the edges
  geom_node_label(aes(label = name, size = Degree), 
                  col = 'red4', fill = 'grey90', alpha = 0.8) +
  scale_edge_width(range = c(0.5, 3.5)) + 
  scale_size(range = c(3, 5)) +
  Pabloverse::theme_print() +
  theme(legend.position = 'none') # set the legend position to bottom
```



# Community detection

In this section we will use different algorithms to identify communities in our network. 

```{r}
# First we need to simplify the network
c <- net %E>%  # we call our network and activate the edges
  mutate(N = as.integer(1)) %>%  # create a variable for the number of movements (each row is 1 movement)
  convert(to_simple) %E>%  # now we will convert it to a simple network
  mutate(weight = map_int(.orig_data, ~.x %>% pull(N) %>% sum())) %N>%  # We have to sum all the repeated movements
  mutate(walktrap = factor(group_walktrap(weights = weight)), # use the walktrap algorithm for community detection
         infomap = factor(group_infomap(weights = weight))) # use the infomap for community detection
```

Then we will create an empty list to fill with plots and compare the different algorithms.

```{r}
# Create the empty list
CP <- list()
# Make a plot for the edges only
pc <- c %>% # our simplified network
  ggraph(layout = 'nicely') + # call the ggraph function
  geom_edge_link() + # add the edges
  theme(legend.position = 'bottom') # set the legend position to bottom

CP[['Infomap']] <- pc + # We call our plot with only the edges
  geom_node_point(aes(col = infomap), size = 2) + # we add the nodes
  labs(title = 'Infomap') # title of our plot

CP[['Walktrap']] <- pc +
  geom_node_point(aes(col = walktrap), size = 2) +
  labs(title = 'Walktrap') 

# We arrange our plots in a single figure
ggarrange(plotlist = CP)
```

```{r}
c %N>% 
  filter(walktrap == '4') %>% # filter for community
  ggraph(layout = 'nicely') + # call the ggraph function
  geom_edge_link() + # add the edges
  geom_node_point(aes(col = walktrap), size = 2) + # we add the nodes
  theme(legend.position = 'bottom') # set the legend position to bottom
```



*Excercise: * Now increase the number of steps in the walk trap algorithm, what happens when we increase the number of steps? What do you think would be the optimal number of steps for this example

```{r eval=FALSE, include=FALSE}
c <- c %N>%
  mutate(walktrap10 = factor(group_walktrap(weights = weight, steps = 10)),
         walktrap15 = factor(group_walktrap(weights = weight, steps = 15)),
         walktrap20 = factor(group_walktrap(weights = weight, steps = 20)))

# Make a plot for the edges only
pc <- c %>% # our simplified network
  ggraph(layout = 'nicely') + # call the ggraph function
  geom_edge_link() + # add the edges
  theme(legend.position = 'bottom') # set the legend position to bottom


# Increase the number of steps until no more groups are created
CP[['Walktrap10']] <- pc +
  geom_node_point(aes(col = walktrap10), size = 2) +
  labs(title = 'Walktrap 10 steps')

CP[['Walktrap15']] <- pc +
  geom_node_point(aes(col = walktrap15), size = 2) +
  labs(title = 'Walktrap 15 steps')

CP[['Walktrap20']] <-pc +
  geom_node_point(aes(col = walktrap20), size = 2) +
  labs(title = 'Walktrap 20 steps')

ggarrange(plotlist = CP[-1])
```

# Spatial representation of the network

Now we will use the network we created and the spatial location of our farms to see the movements on a map.  
We will be using the `sf` package to manipulate the spatial objects, and the `ggplot2` package for visualization.  
In the `STNet` package there is a spatial polygons data, which includes the counties in the state of Iowa.  

```{r}
# Loading the packages
library(sf) # Package for spatial objects
library(ggplot2) # package for plots

# We load the spatial object from the package STNet
iowa <- st_read(system.file("data/Io.shp", package = "STNet"))

# plot map using sf
plot(iowa$geometry)
```

Next we will transform the nodes as a spatial points object, for this we use the function `st_to_sf()` and we need to specify the names of the columns that have the spatial coordinates.    

```{r Transform nodes to spatial}
NodeSp <- node %>% # This is our node data.frame
  st_as_sf(coords = c("long", "lat"), # Variables for the coordinates
           crs = st_crs(iowa)) # This is the CRS we are using
```


## Plotting our map

One of the nice things of ggplot is that we can create a map and store it in an object and later we can keep adding layers to this map. So first we will create a map of the state.    

```{r}
map <- ggplot() +
  geom_sf(data = iowa, # name of the spatial dataset
          color="grey20", # color of the shape border
          fill="white", # fill of the shape
          size=0.4) + # width of the border
  theme_void() # This is a theme form ggplot
```


## Plot the nodes

Once we have the base map of the state, we can add the spatial points data we created previously. We can specify the size of the points using a variable.  

```{r}
map + geom_sf(data = NodeSp, # name of our data
              aes(color = farm_type, # we color the nodes by farm type
                  size = indegree)) +
  ggtitle("Farms and their indegree") # the title of our plot
```

**Excercise:** Make the same plot, but make the size of the nodes relative to outdegree



## Adding the euclidean contacts

In the previous lab we calculated the euclidean distance between each pair of farms involved in a movement. Here we will visualize those movements.  

```{r}
# The function geom_segment adds a straight line between two coordinates:
map +
  geom_segment(data=edge, 
               aes(x=O_Long, y=O_Lat, # this is where the line starts
                   xend=D_Long, yend=D_Lat)) # this is where it ends

# We can add the information of the type of movement to change the color of the line and the number of animals for the transparency
map +
  geom_segment(data=edge, 
               aes(x=O_Long, y=O_Lat,
                   xend=D_Long, yend=D_Lat, 
                   color=type_orig,
                   alpha = pigs.moved))
```


## Putting everything together

Now we will add both the farm locations and the direction of the movements between the farms on a map.  

```{r}
#plot nodes & edges - add both commands geom_segment and geom_point#
map +
  geom_segment(data=edge, 
               aes(x=O_Long, y=O_Lat,
                   xend=D_Long, yend=D_Lat,
                   alpha = pigs.moved), 
               show.legend=F) +
  geom_sf(data = NodeSp, 
          aes(color = farm_type, 
              size = indegree), show.legend = "point")
```


## Subsetting the data

Sometimes we are interested in a particular type of movements. We can subset this using the dplyr functions such as `filter()`. In the next plot we will select only the movements that comes from sow farms.  

```{r}
# plot movements from sow farms only
map +
  edge %>%
  filter(type_orig == "sow farm") %>%
  geom_segment(data = ., 
               aes(x=O_Long, y=O_Lat, 
                   xend=D_Long, yend=D_Lat, 
                   color = type_orig), show.legend = F) +
  geom_sf(data = NodeSp, 
          aes(color = farm_type), size=3, show.legend = "point")
```
  
  We can be even more specific and filter the movements from sow farms that are directed to GDU.  
We will also add at the end the function `ggplotly()` from the package `plotly` to obtain a map were we can zoom and hover over some features to obtain more information.  

  
```{r}
# We store the map of movements between GDU to sow farm
m <- map +
  edge %>%
  filter(type_orig == 'GDU', type_dest == "sow farm") %>%
  geom_segment(data = ., aes(x=O_Long, y=O_Lat,
                             xend=D_Long, yend=D_Lat, 
                             color = type_orig), show.legend = F) +
  geom_sf(data = NodeSp, 
          aes(color = farm_type),
          size=3, show.legend = "point") +
  ggtitle("GDU to Sow farm Movments")

# We use the function from plotly to transform our map into n interactive map.  
library(plotly)

ggplotly(m)
```


# Kernel density map

Like we just saw, visualizing the movements can be challenging, one approach to do this is using a kernel density map. The idea behind this is to extrapolate values in a continuous surface, but here we are just interested in the visualization of the values, not so much in the interpolation of our values.  
We will use the package `KernSmooth` for this, so make sure you ahve it installed.  
First we will define a function to automate the process:  

```{r}
library(KernSmooth)
library(raster)
# we will create a function to create a density raster:
processRaster <- function(x, b, shp, res = c(200, 200)) {
  est <- bkde2D( # we use the function bkde2D to obtain our values
    x, # This will be our dataset
    bandwidth = c(b, b), # The bandwidth we define
    gridsize = res, # the resolution level we want
    range.x = list(extent(shp)[c(1, 2)], extent(shp)[c(3:4)])
  )
  
  # Add the results to a raster
  r <- raster(list(
    x = est$x1,
    y = est$x2,
    z = est$fhat
  )) %>%
    `projection<-`(st_crs(iowa)) %>% # set the CRS
    `extent<-`(extent(iowa)) %>% # set the extent
    crop(., iowa) %>% # crop the raster to the area
    mask(., iowa) # crop the raster to the stat shape
  
  return(r)
}
```

Now lets use our function for the data.  

```{r}
# Obtain the estimated kernel with bandwidth 2km
Erc <- processRaster(x = edge[,c("O_Long", "O_Lat")], # we want the outgoing only
                     b = 2, # we choose a bandwidth of 2
                     shp = iowa) # we set our extent 

# plot the raster and the map
plot(Erc)
plot(iowa$geometry, col=NA, border = "grey80", add = T)
```

We might have used a very large bandwidth in the previous plot, lets try with a smaller size.  

```{r}
# Using a different bandwidth
Erc <- processRaster(x = edge[,c("O_Long", "O_Lat")],
                     b = 0.1,
                     shp = iowa)

# plot the raster and the map
plot(Erc)
plot(iowa$geometry, col=NA, border = "grey80", add = T)
```

**Exercise:** Create a kernel density map for the incoming movements.  

___________________________________________________

# More on interactive maps. 

If you are interested in more about interactive maps `plotly` also has option for using background maps, but for this you need to get a public [Mapbox access token](https://www.mapbox.com/studio), which is free, but requires registration. Some great resources for more information:  
  
  - https://plotly-r.com/maps.html
  - https://plotly.com/r/maps/

Here I provide an example of the kind of maps you can get using mapbox, but this **This code will not run unless you use your own API Key**

```{r include=FALSE}
Sys.setenv('MAPBOX_TOKEN' = 'pk.eyJ1Ijoiam9zZXBhYmxvOTEiLCJhIjoiY2tsaXR5ZGd3MmJoNzJ3bWxrbTF5emw1eSJ9.THUKAPF8TYZ-qpIDKD5Icg')
```



```{r}
# Sys.setenv('MAPBOX_TOKEN' = yourKey)

plot_mapbox() %>%
  add_segments(
    data = group_by(edge, id_orig, id_dest),
    x = ~O_Long, xend = ~D_Long,
    y = ~O_Lat, yend = ~D_Lat,
    alpha = 0.1, size = I(1), hoverinfo = "none"
  )   %>%
  add_markers(data = node,
    x = ~long, y = ~lat, size = ~indegree, text = ~id,
    split = ~farm_type,
    hoverinfo = "text"
  ) %>%
  layout(
    mapbox = list(
      style = 'open-street-map',
      zoom = 6,
      center = list(lat = 42, lon = -93)
    ))
```

  

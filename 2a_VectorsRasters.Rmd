---
title: "Vectors and Rasters"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = F, message = F)
library(dplyr); library(ggplot2); library(ggpubr);library(Pabloverse)
library(sf)
```

# Introduction.  

Spatial data is usually represented in two different ways:  

  - *Vectors*: Represent objects in different dimensions.  
  - *Raster*: Represent continuous values in a grid.  
  
## Spatial objects in R.  

In this tutorial we will introduce to spatial data manipulation in R.  
There are two main formats to manipulate spatial data in R:  
  - **SpatialDataFrame** from the `sp` package: This is was the first format introduced in R for spatial data manipulation, therefore, this package has a lot of dependencies (packages that uses this format to do other functions) i.e `raster`, `spdep`, `spstat`.  
  - **Simple features** from the package `sf`: This is a more recently developed package, this package was developed to be more intuitive and friendly with other packages such as `dplyr`. The problem with this package is that since its more recent, some packages doesn't support this format.  
  
Working with both formats has its advantages, for spatial data manipulation `sf` is more intuitive and powerful, but for spatial analysis `sp` is more robust.  

Here we will use mostly the `sf` package, but there will be times that we will need to switch between formats.  

We will continue using the library `STNet` to get the data we will be using in this exercise. Just in case you have not installed it yet, the installation of this package is done from github, so we will need to install the package`devtools` to access the `STNet` package.

```{r eval=FALSE}
# If devtools is not installed we need to install it
install.packages("devtools")
# once installed we can use the following function to install STNet
devtools::install_github("jpablo91/STNet")
```
  
________________________________________
  
# Vector data

Spatial objects can be represented in multiple dimesions:  

  - *Point*, is the most basic form of representing spatial data. It contains only the spatial coordinates of an even or object. For example, we use this to represent the spatial location of a farm, a capture of an animal or a case report.  
  - *Line*, Includes the spatial location of an object and the direction. we can use lines to represent a road, a river or a route.  
  - *Polygon*, Includes the spatial location and geometry of an object. We use polygon data to represent the shape of a building, lake or a administrative area.  
  
Besides having the location of an object, we can include other characteristics such as the name, id, temperature recorded, number of animals in the farm, etc...  

## Components of spatial datasets

There are multiple ways to loading spatial data into R, we will use the function `st_read()` to load the data contained in the STNet library. lets get started:

```{r}
# Loading the libraries
library(STNet) 
library(sf)
library(dplyr)

# Loading the spatial data from the package
MxSp <- st_read(system.file("data/MxShp.shp", package = "STNet")) 
```

The whole data set is a shapefile of Mexico aggregated at the administration level 3 (Municipality). Since we will not be using the whole country for our analysis, we will filter the data only for the study region. Luckly for us, we can use the same function `filter()` we are already familiarized with:

```{r}
# Filter to study area
Area <- MxSp %>% # This is the data we will filter
  filter(CVE_ENT %in% c('15', '12', '16')) %>%  # Filter the data to use the states with codes: 15, 12 y 16
  st_transform(crs = st_crs(4326)) # transform to lat/long
```

Notice that the last line transformed the data to a different coordinate reference system, we will talk more about this later. Lets examine the data for now:

```{r}
head(Area)
```

## Projecting the data.

Our spatial data is in the WGS84 CRS, which is a non-projected format. Good for locations, bad for measuring distances. The impact of the projection in our data will be associated with the size of our study area. In smaller areas the projection wont have a big impact, but as our study are increases the projection will have a bigger impact when calculating distances.  
We can use the function `st_transform()` to set a projection to our data.  
  
*How do I know which projection to use?* We can use tools such as [epsg.io](https://epsg.io/) to look for the area we will be working and identify the most proper projection. In this exercise we will use the WGS84 CRS.

The output shows:  
  - `geometry type`: The type of shapefile (either point data, lines or polygons).
  - `dimension` Dimensions used in the data.  
  - `Bounding bix`: The extent of our data.  
  - `CRS`: The coordinate reference system.  
  - And the first 10 features.  

The `sf` objects are basically a data.frame with extra information about geometry, projection and CRS. We can ask for the geometry only using the `$` operator or the function `st_geometry()`and then show it in a plot.  
  
```{r}
plot(Area$geometry)
```

We can also extract only the data frame without geometry using the function `data.frame()`:  

```{r}
data.frame(Area) %>%
  head() # We use this function to see the first 6 only
```

### What is the coordinate reference system?

The coordinate reference system (CRS) is a format to specify the scale for the coordinates being used to describe the location of our data. The most commonly used CRS is WGS84, which provides the latitude and longitude values in a scale of -90 to 90 for latitude and -180 to 180 for longitude. THis CRS is ideal to report locations in a map but it is important to consider that does not takes into account the curvature of the earth, which is an important factor when we are measuring distances.  
  
To see the full description of the CRS from a spatial object we can use the function `st_crs()`: 

```{r}
st_crs(Area)
```


## Point data (converting from a data frame)

We can convert a data.frame to a spatial points if we have the coordinates information, lets try with one of the data sets from the STNet library:

```{r}
data('captura') # we lead the data
# Lets look at the variables
head(captura)
```

This data has the column *LATITUD* and *LONG*, which correspond with x and y for a spatial coordinate. We can use the function `st_as_sf()` to do this:

```{r}
capturaSp <- captura %>% 
  st_as_sf(
    coords = c('LONG', 'LATITUD'), # the names of the variables with the x and y information
    crs = st_crs(4326) # the CRS for those coordinates
  )

# Lets have a look at our points
plot(capturaSp$geometry)
```

You will notice that the points by itself does not provides a lot of useful information. Lets try to put the points and the polygons in the same map:

```{r}
plot(Area$geometry)
plot(capturaSp$geometry, add = T)
```

Still not pretty enough, we will work more on this later...

## Joining spatial objects

So far we have two kind of spatial objects, we can extract the information for the points to the polygons by joining based on where they intersect, for this we can sue the `st_join()` function. It is important that the two spatial objects are in the same CRS.

```{r}
spJoin <- Area %>% 
  st_join(capturaSp)

# Lets examine our object
head(spJoin)
```

If we look at our object, we will notice that it is a Multipolygon with 606 observations now, instead of the original 319 observations from the Area file. This is beacause there were more than one point joined to each polygon, so there are some repeated polygons. We can use the tools we have used before to summarise the total number of captures by municipality.

```{r}
spJoin <- spJoin %>% 
  data.frame() %>% # first we will transfor to a data.frame (this makes easier for the aggregation)
  group_by(CVEGEO) %>% 
  summarise(captures = sum(CAPTURADOS, na.rm = T), treated = sum(TRATADOS, na.rm = T))

# Lets look at the result
head(spJoin)
```

Now we have a data.frame with the Municipality ID and the number of captures and treated. But the problem is that we have lost all the other spatial information when we did this. We can just join this new data.frame with the one with the spatial information, for this we can use the function `left_join()`:

```{r}
Area <- Area %>% 
  left_join(spJoin, by = 'CVEGEO')

# Now that we have all the information in a single file we can see the captures by municipality:
plot(Area['captures'])
```

<!-- Lines -->

<!-- # Rasters -->

## Raster data:

We use raster data to represent continuous values in a field. Raster are just a grid where each cell has a value and in a grid. The resolution of a raster just represent the size of the cells from the grid. We use raster data to represent values such as altitude, temperature, among other continuous values.  

There are multiple ways to get raster data, one example is getting the data directly from R. We can use the function `getData()` from the `raster()` package to get altitude data:

```{r}
library(raster)
MxAlt <- getData('alt', country='MEX') # get the data for the whole country

plot(MxAlt) # see the data
```

Rasters are basically grids with a specific resolution and a value associated to each pixel. You can see the information it includes by printing the object:

```{r}
MxAlt
```

This raster is projected in WGS84 and has values between -174 to 5389. Lets extract only the information for our study area:

```{r}
library(stars)

Mxst <- stars::st_as_stars(MxAlt) %>% 
  st_crop(., Area)

ggplot() +
  geom_stars(data = Mxst) +
  theme_void()
```

# Putting everything together wit ggplot



```{r}
ggplot() +
  geom_stars(data = Mxst) +
  geom_sf(data = Area, fill = NA, col = 'grey60') +
  geom_sf(data = capturaSp, cex = 0.3) +
  theme_void() +
  scale_fill_gradient(low = 'black', high = 'red')
```

___________________________________________
  
# Getting data for other countries/regions

One of the easiest ways to get data from other countries or regions is downloading directly from R using the `raster` library. For example, we will get a shapefile for Denmark. The data will be downloaded in your computer and store in your project directory. Once downloaded you can just load it directly from your computer without internet connection with the function `read_sf`.

```{r}
Sp <- raster::getData(name = 'GADM', # this is the data source
                      level = 1, # Level of administration
                      country = 'Mx') %>%  # country code
  st_as_sf() # Now transform the data to sf

# the dataset can be quite detailed, so we can simplify it to make it easier to plot
Sp <- rmapshaper::ms_simplify(Sp)

# Plot the map
ggplot() +
  geom_sf(data = Sp) +
  theme_void()
```

